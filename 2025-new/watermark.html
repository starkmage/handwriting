<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .watermark-container::after {
      content: "";
      /* 伪元素必须有 content 属性 */

      /* 1. 全屏覆盖 */
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;

      /* 2. 保证在最上层，但又不影响内容 */
      z-index: 9999;
      pointer-events: none;
      /* 关键：让鼠标事件穿透水印层 */

      /* 3. 使用 SVG 创建并重复背景水印 */
      background-repeat: repeat;
      background-position: center;

      /* * SVG Data URI:
   * - <svg> 定义画布大小和 XML 命名空间
   * - <text> 定义文本内容、位置、样式
   * - transform="rotate(-30)" 将文本旋转-30度
   * - fill="rgba(0,0,0,0.1)" 设置半透明的填充色
   * - 最后通过 Base64 编码或直接 URI 编码后使用
   */
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNTAiIGhlaWdodD0iMTAwIj48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0icmdiYSgwLDAsMCwwLjEpIiBmb250LXNpemU9IjE2cHgiIGZvbnQtZmFtaWx5PSJtb25vc3BhY2UiIHRyYW5zZm9ybT0icm90YXRlKC0zMCkiPkhlbGxvV29ybGQ8L3RleHQ+PC9zdmc+");
    }
  </style>
</head>

<body>
  <div id="watermark-container" class="watermark-container">
    <h1>Page Title</h1>
    <p>This is the main content of the page...</p>
  </div>

  <script>
    // 防止水印被删除
    // 确保在 DOM 加载完毕后执行
    document.addEventListener('DOMContentLoaded', () => {

      // 1. 获取需要保护的、依附伪元素的真实DOM节点
      const watermarkHost = document.getElementById('watermark-container');
      if (!watermarkHost) {
        console.error('Watermark host element not found!');
        return;
      }

      // 保存一份原始的 class，以便恢复
      const originalClassName = watermarkHost.className;

      // 2. 创建一个 MutationObserver 实例来观察 DOM 变化
      const observer = new MutationObserver((mutationsList) => {
        // 遍历所有发生的变更
        for (const mutation of mutationsList) {

          // a. 检查 watermarkHost 元素的属性是否被修改
          if (mutation.type === 'attributes' && mutation.target === watermarkHost) {
            // 如果 class 被移除了，就把它加回去
            if (!watermarkHost.classList.contains('watermark-container')) {
              console.warn('Watermark class was removed. Re-applying it.');
              // 恢复原始 class
              watermarkHost.className = originalClassName;
            }
          }

          // b. 检查 watermarkHost 元素是否被从 body 中删除
          if (mutation.type === 'childList') {
            mutation.removedNodes.forEach(removedNode => {
              // 如果被删除的节点就是我们的水印宿主，就把它重新加回 body
              if (removedNode === watermarkHost) {
                console.warn('Watermark host was removed. Re-appending it.');
                document.body.appendChild(watermarkHost);
              }
            });
          }
        }
      });

      // 3. 配置 observer 需要观察的内容
      const observerConfig = {
        attributes: true,  // 观察目标节点的属性变化 (比如 class, style)
        childList: true,   // 观察目标节点的子节点列表变化 (比如删除)
        subtree: true      // 观察所有后代节点
      };

      // 4. 启动观察
      // 我们需要观察 body，以防 watermarkHost 整个被删除
      observer.observe(document.body, observerConfig);

      console.log('Watermark protection is active.');
    });
  </script>
</body>

</html>